<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of make_bc_sca_var</title>
  <meta name="keywords" content="make_bc_sca_var">
  <meta name="description" content="MAKE_BC_SCA_VAR creates scalings for the boundary condition and goal">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html src -->
<h1>make_bc_sca_var
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>MAKE_BC_SCA_VAR creates scalings for the boundary condition and goal</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [bsca, regsca] = make_bc_sca_var(A,grid,region,bcon) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MAKE_BC_SCA_VAR creates scalings for the boundary condition and goal
 region using esimations of the matrices from the ktensor of the operator
 op. op is here denoted by A since the code is a modification of
 the code ALS_ONSTEP_SYS.
 Inputs:
   A - the operator (op).
   grid - the discratization grid.
   region - the dimensions of the goal region.
   bcon - the boundary conditions. bcon{i} is boundary conditions in
   dimension i:
      bcon{i} = {'p'}. Periodic
      bcon{i} = {'d',val_lo,val_up}. Dirichlet with val_lo and val_up 
      for lower and upper boundary in dimension i.
      bcon{i} = {'n',val_lo,val_up}. Neumann with val_lo and val_up for
      lower and upper boundary in dimension i.
      where all the values are for the desirability function.
   bsca - boundary scaling. bsca(i,1) and bsca(i,2) is how much lower and
   upper boundary in dimension i should be scaled.
 Outputs:
   bsca - boundary scaling. bsca(i,1) and bsca(i,2) is how much lower and
   upper boundary in dimension i should be scaled.
   regsca - how much the goal region should be scaled.

 See also <a href="main_run.html" class="code" title="function [F, grid] = main_run(input1,input2,input3,input4,run,save_folder)">MAIN_RUN</a>.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="main_run.html" class="code" title="function [F, grid] = main_run(input1,input2,input3,input4,run,save_folder)">main_run</a>	MAIN_RUN obtains the solution to the setup specified in MAIN_PROGRAM,</li><li><a href="main_run_spectral.html" class="code" title="function [F, grid] = main_run_spectral(input1,input2,input3,input4,run,save_folder)">main_run_spectral</a>	MAIN_RUN obtains the solution to the setup specified in MAIN_PROGRAM,</li><li><a href="../test/test_finite_horizon_hjb_backward_euler.html" class="code" title="">test_finite_horizon_hjb_backward_euler</a>	Test finite horizon hjb, backward euler</li><li><a href="../test/test_finite_horizon_hjb_euler.html" class="code" title="">test_finite_horizon_hjb_euler</a>	Test finite horizon hjb, forward euler</li><li><a href="../test/test_finite_horizon_hjb_scaling.html" class="code" title="">test_finite_horizon_hjb_scaling</a>	Finite Horizon</li><li><a href="../test/test_infinite_horizon_hjb.html" class="code" title="">test_infinite_horizon_hjb</a>	Test finite horizon hjb, backward euler</li><li><a href="../test/test_run_spectral_heat.html" class="code" title="function test_run_spectral_heat()">test_run_spectral_heat</a>	Wave equation (3.13, pg 24) in Spectral Methods in MATLAB by Trefethen</li><li><a href="../test/test_run_spectral_helmholtz.html" class="code" title="function test_run_spectral_helmholtz(run)">test_run_spectral_helmholtz</a>	Helmholtz equation (7.6) in Spectral Methods in MATLAB by Trefethen</li><li><a href="../test/test_run_spectral_periodic.html" class="code" title="function test_run_spectral_periodic(run)">test_run_spectral_periodic</a>	Poisson equation (pg 119) in Spectral Methods in MATLAB by Trefethen</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [bsca, regsca] = make_bc_sca_var(A,grid,region,bcon)</a>
0002 <span class="comment">% MAKE_BC_SCA_VAR creates scalings for the boundary condition and goal</span>
0003 <span class="comment">% region using esimations of the matrices from the ktensor of the operator</span>
0004 <span class="comment">% op. op is here denoted by A since the code is a modification of</span>
0005 <span class="comment">% the code ALS_ONSTEP_SYS.</span>
0006 <span class="comment">% Inputs:</span>
0007 <span class="comment">%   A - the operator (op).</span>
0008 <span class="comment">%   grid - the discratization grid.</span>
0009 <span class="comment">%   region - the dimensions of the goal region.</span>
0010 <span class="comment">%   bcon - the boundary conditions. bcon{i} is boundary conditions in</span>
0011 <span class="comment">%   dimension i:</span>
0012 <span class="comment">%      bcon{i} = {'p'}. Periodic</span>
0013 <span class="comment">%      bcon{i} = {'d',val_lo,val_up}. Dirichlet with val_lo and val_up</span>
0014 <span class="comment">%      for lower and upper boundary in dimension i.</span>
0015 <span class="comment">%      bcon{i} = {'n',val_lo,val_up}. Neumann with val_lo and val_up for</span>
0016 <span class="comment">%      lower and upper boundary in dimension i.</span>
0017 <span class="comment">%      where all the values are for the desirability function.</span>
0018 <span class="comment">%   bsca - boundary scaling. bsca(i,1) and bsca(i,2) is how much lower and</span>
0019 <span class="comment">%   upper boundary in dimension i should be scaled.</span>
0020 <span class="comment">% Outputs:</span>
0021 <span class="comment">%   bsca - boundary scaling. bsca(i,1) and bsca(i,2) is how much lower and</span>
0022 <span class="comment">%   upper boundary in dimension i should be scaled.</span>
0023 <span class="comment">%   regsca - how much the goal region should be scaled.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% See also MAIN_RUN.</span>
0026 
0027 <span class="comment">% Elis Stefansson, Aug 2015</span>
0028 
0029 A = arrange(A);
0030 d = ndims(A);
0031 rA = ncomponents(A);
0032 sizeA = size(A);
0033 
0034 <span class="comment">% distribute the normalization constants evenly, so one does not need to</span>
0035 <span class="comment">% worry about normailization constants.</span>
0036 <span class="keyword">for</span> i = 1:d
0037     A.U{i} = A.U{i}*diag((A.lambda).^(1/d));
0038 <span class="keyword">end</span>
0039 A.lambda = ones(rA,1);
0040 
0041 <span class="comment">% convert to matrices</span>
0042 <span class="keyword">for</span> k = 1:d
0043     nf = sqrt(sizeA(k));
0044     Acell{k} = reshape(A.U{k},nf,nf,rA);
0045 <span class="keyword">end</span>
0046 
0047 regsca = 0;
0048 
0049 <span class="keyword">for</span> k = 1:d
0050     
0051     bconi = bcon{k};
0052     
0053     nf = sqrt(sizeA(k));
0054     matrix_sum = zeros(nf,nf);
0055     weight_sum = 0;
0056     
0057     <span class="comment">% Step 1. get weighted matrix sum in dimension i</span>
0058     <span class="keyword">for</span> ia = 1:rA
0059         
0060         A_k_ia = Acell{k}(:,:,ia);
0061         weight = norm(A_k_ia); <span class="comment">%scale term with how big it is</span>
0062         
0063         matrix_sum = matrix_sum+A_k_ia*weight;
0064         weight_sum = weight_sum+weight;
0065         
0066     <span class="keyword">end</span>
0067     matrix_sca = matrix_sum/weight_sum; <span class="comment">%take weigthed average</span>
0068     
0069     <span class="comment">% Step 2. get scalings from matrix_sca</span>
0070     
0071     du = abs(diag(matrix_sca,1));
0072     dd = abs(diag(matrix_sca,0));
0073     dl = abs(diag(matrix_sca,-1));
0074     
0075     <span class="comment">% for outer bc</span>
0076     sca_lo = sum( du(2:3)+dd(2:3)+dl(2:3) )/6; <span class="comment">%average</span>
0077     sca_up = sum( du(end-2:end-1)+dd(end-2:end-1)+dl(end-2:end-1) )/6;
0078     
0079     <span class="keyword">if</span> strcmp(bconi{1},<span class="string">'p'</span>) == 1 <span class="comment">%then must have the same scalings</span>
0080         <span class="comment">% take mean</span>
0081         bsca(k,1) = (sca_lo+sca_up)/2;
0082         bsca(k,2) = (sca_lo+sca_up)/2;
0083     <span class="keyword">else</span>
0084         bsca(k,1) = sca_lo;
0085         bsca(k,2) = sca_up;
0086     <span class="keyword">end</span>
0087     
0088     <span class="comment">% for region</span>
0089     <span class="keyword">if</span> isempty(region) == 0
0090         gridi = grid{k};
0091         
0092         reg_idx = find(gridi&gt;=region(k,1) &amp; gridi&lt;=region(k,2));
0093         reg_min = min(reg_idx);
0094         reg_max = max(reg_idx);
0095         
0096         s1 = sum( du(reg_min-2:reg_min-1)+dd(reg_min-2:reg_min-1)+dl(reg_min-2:reg_min-1) );
0097         s2 = sum( du(reg_max+1:reg_max+2)+dd(reg_max+1:reg_max+2)+dl(reg_max+1:reg_max+2) );
0098         
0099         sca_reg = (s1+s2)/12; <span class="comment">%take mean</span>
0100         regsca = regsca+sca_reg;
0101     <span class="keyword">end</span>
0102     
0103 <span class="keyword">end</span>
0104 
0105 <span class="keyword">if</span> isempty(region) == 0
0106     regsca = regsca/d;
0107 <span class="keyword">end</span>
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117</pre></div>
<hr><address>Generated on Fri 12-Jan-2018 11:28:53 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>